		case 12:
		{
			DBGPrintf("\nVibration\n");
			packet_[0] = 0x18; // try full 0x30?; // Report ID
			packet_[1] = 0x03; // try full 0x30?; // Report ID
			packet_[2] = 0x72; // try full 0x30?; // Report ID
			packet_[3] = 0x00; // try full 0x30?; // Report ID
			packet_[4] = 0x00; // try full 0x30?; // Report ID
			packet_[5] = 0x00; // try full 0x30?; // Report ID
			packet_[6] = 0x00; // try full 0x30?; // Report ID
			sw_sendCmd_norumble(0x10, 0x03, packet_, 7);
			connectedComplete_pending_ = 0;
        }
			break;
			
			
			
		uint8_t packet_[8];
		
        switch (connectedComplete_pending_) {
		case 1:
			DBGPrintf("\nTry to Enable IMU\n");
			packet_[0] = 0x01;
			sw_sendCmd(0x40, packet_, 1);   /* 0x40 IMU, note: 0x00 would disable */
			connectedComplete_pending_ = 2;
			break;
		case 2:
			DBGPrintf("\nTry to Enable Rumble\n");
			packet_[0] = 0x00;
			sw_sendCmd(0x48, packet_, 1);
			connectedComplete_pending_ = 3;
			break;
		case 3:
			DBGPrintf("\nSet Report Mode\n");
			packet_[0] = 0x30; //0x3F;
			sw_sendCmd(0x03, packet_, 1);
			connectedComplete_pending_ = 4;
			break;
        case 4:
            DBGPrintf("\nTry to set LEDS\n");
            setLEDs(0x1, 0, 0);
            connectedComplete_pending_ = 5;
            break;
		case 5:
		{
			DBGPrintf("\nVibration\n");
			packet_[0] = 0x18; // try full 0x30?; // Report ID
			packet_[1] = 0x03; // try full 0x30?; // Report ID
			packet_[2] = 0x72; // try full 0x30?; // Report ID
			packet_[3] = 0x00; // try full 0x30?; // Report ID
			packet_[4] = 0x00; // try full 0x30?; // Report ID
			packet_[5] = 0x00; // try full 0x30?; // Report ID
			packet_[6] = 0x00; // try full 0x30?; // Report ID
			sw_sendCmd_norumble(0x10, 0x03, packet_, 7);
			connectedComplete_pending_ = 0;
        }
			break;
		}
		
		
bool BluetoothController::setTimer(BluetoothConnection *connection, uint32_t us)  // set to NULL ptr will clear:
{
    static uint32_t millis_last = 0;
    DBGPrintf("BluetoothController::setTimer(%p, %u) TO:%u, dt:%u\n", connection, us,
        millis(), millis()-millis_last);
    millis_last = millis();
    if (connection == nullptr) {
        timer_connection_ = nullptr;
        timer_.stop();
        return true;
    } else if ((timer_connection_ == nullptr) || (connection == timer_connection_)) {
        timer_connection_ = connection;
        timer_.start(us);
        return true;
    }
    return false;
}


https://gigazine.net/gsc_news/en/20171107-nintendo-switch-reverse-engineering/

https://github.com/shinyquagsire23/HID-Joy-Con-Whispering/blob/master/hidtest/hidtest.cpp

https://douevenknow.us/post/160976568023/picking-apart-the-joy-con-pro-controllers

https://stackoverflow.com/questions/54971412/is-it-possible-to-command-the-nintendo-switchs-joy-cons-with-a-pc

